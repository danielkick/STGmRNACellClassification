geom_point(size = 2)+
facet_grid(.~target)+
scale_color_brewer(type = "qual", palette = 3)
data5 <- gather(data4, target, mean, 2:5)
ggplot(data5, aes(x = type, y = mean, group = Cell, color = Cell))+
geom_line(size = 2)+
facet_grid(.~target)+
scale_color_brewer(type = "qual", palette = 3)
ggplot(gather(data4.ratio, target, seqTOpcr, 2:5),
aes(x = Cell, y = seqTOpcr, group = Cell, color = Cell))+
geom_point(size = 2)+
facet_grid(.~target)+
scale_color_brewer(type = "qual", palette = 3)
data5
data6 <- spread(data5, type, mean)
data6
ggplot(data6, aes(x = PCR, y = SEQ, group = Cell, color = Cell))+
geom_line(size = 2)+
facet_grid(.~target)+
scale_color_brewer(type = "qual", palette = 3)
ggplot(data6, aes(x = PCR, y = SEQ, group = Cell, color = Cell))+
geom_point(size = 2)+
#facet_grid(.~target)+
scale_color_brewer(type = "qual", palette = 3)
ggplot(data6, aes(x = PCR, y = SEQ, group = Cell, color = Cell))+
geom_smooth()+
geom_point(size = 2)+
#facet_grid(.~target)+
scale_color_brewer(type = "qual", palette = 3)
ggplot(data6, aes(x = PCR, y = SEQ, color = Cell))+
geom_smooth()+
geom_point(size = 2)+
#facet_grid(.~target)+
scale_color_brewer(type = "qual", palette = 3)
ggplot(data6, aes(x = PCR, y = SEQ, color = Cell))+
geom_smooth(aes(group = 1))+
geom_point(size = 2)+
#facet_grid(.~target)+
scale_color_brewer(type = "qual", palette = 3)
ggplot(data6, aes(x = PCR, y = SEQ, color = Cell))+
geom_smooth(aes(group = 1), method = lm)+
geom_point(size = 2)+
#facet_grid(.~target)+
scale_color_brewer(type = "qual", palette = 3)
ggplot(data6, aes(x = PCR, y = SEQ, color = Cell))+
geom_smooth(aes(group = 1), method = lm)+
geom_point(size = 2)+
facet_grid(.~Cell)+
scale_color_brewer(type = "qual", palette = 3)
ggplot(data6, aes(x = PCR, y = SEQ, color = Cell))+
geom_smooth(, method = lm)+
geom_point(size = 2)+
facet_grid(.~Cell)+
scale_color_brewer(type = "qual", palette = 3)
ggplot(data6, aes(x = PCR, y = SEQ, color = Cell))+
geom_smooth(method = lm)+
geom_point(size = 2)+
facet_grid(.~Cell)+
scale_color_brewer(type = "qual", palette = 3)
ggplot(data6, aes(x = PCR, y = SEQ, color = Cell))+
geom_smooth(method = lm)+
geom_point(size = 2)+
#facet_grid(.~Cell)+
scale_color_brewer(type = "qual", palette = 3)
ggplot(data6, aes(x = PCR, y = SEQ))+
geom_smooth(method = lm)+
geom_point(aes(color = Cell), size = 2)+
#facet_grid(.~Cell)+
scale_color_brewer(type = "qual", palette = 3)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache=F)
tic <- Sys.time()
# General + Plotting ----------------------------------------------------------
library(tidyverse) #ggplot2, purrr, dplyr, tidyr mostly
library(cowplot) #clean up ggplots ands plotgrid
library(M3Drop) #for BrenneckeGetVariableGenes
# install_github("vqv/ggbiplot")
library(ggbiplot)
# Cluster Determination -------------------------------------------------------
library(factoextra) #for fviz_nbclust
library(NbClust) #to automate cluster determination for each dataset
# Clustering ------------------------------------------------------------------
library(BiocGenerics) # This is used for clustering assessment
library(pvclust) #for pvclust
library(dendextend) #for cutree coloring dendrograms
library(NMF) #used for calculating purity metric
library(clues) #used for calculating concurrance metrics
# Classification --------------------------------------------------------------
#install.packages("caret", dependencies = c("Depends", "Suggests"))
library(caret) # for preProcess and supervised ML models
library(devtools)
devtools::load_all() #needed to have access to SNN.R
# Chunk 3: Conrol block
#What should happen to plots?
#save
#show
#What should happen to output data?
#save
#show
#Which sections should be run?
# Visualizations
# Cluster.estimation
# Clustering
# Classification
run.snn.cliq <- TRUE # SNN Cliq depend on python. This script is written to work on windows and hasn't been tested on Unix/Macos. Needed file is in ../Py. At the point of writing, python version 3.7 has beed tested.
write.to.dir <- paste0(getwd(), "/inst/extdata/output_files/")
use.seed <- 8743436
# Chunk 5: Pull in datasets
# Read in all data ------------------------------------------------------------
mrna_raw <- read.csv(paste0(getwd(),"/inst/extdata/RTqPCR.csv"), row.names = "Sample", header = TRUE) %>% as.data.frame()
seq_raw <- read.csv(paste0(getwd(),"/inst/extdata/scSeq.csv"), row.names = "id", header = TRUE) %>% t() %>% as.data.frame()
k2 <- read.csv(paste0(getwd(),"/inst/extdata/kallisto0.2.csv"), header = F) %>% as.data.frame()
k05 <- read.csv(paste0(getwd(),"/inst/extdata/kallisto0.05.csv"), header = F) %>% as.data.frame()
# Transform RTqPCR data -------------------------------------------------------
mrna_raw <- predict(preProcess(mrna_raw, method = c("medianImpute", "zv")), mrna_raw)
mrna_target <- predict(preProcess(mrna_raw, method = c("center", "scale")), mrna_raw)
# mrna_cell <- mrna_raw[,-1]
# mrna_cell <- as.data.frame(t(mrna_cell))
# mrna_cell <- predict(preProcess(mrna_cell, method = c("center", "scale")), mrna_cell)
# mrna_cell <- cbind(Cell = mrna_raw$Cell, as.data.frame(t(mrna_cell)))
# Transform Seq data ----------------------------------------------------------
seq_raw <- predict(preProcess(seq_raw, method = c("zv")), seq_raw)
seq_target <- predict(preProcess(seq_raw, method = c("center", "scale")), seq_raw)
# # center and scale by cell
# seq_cell <- seq_raw
# seq_cell <- as.data.frame(t(seq_cell))
# seq_cell <- predict(preProcess(seq_cell, method = c("center", "scale")), seq_cell)
# seq_cell <- as.data.frame(t(seq_cell))
# Set up a cell id vector to use in each dataframe
split.names <- rownames(seq_raw) %>% strsplit("[.]")
split.names <- unlist(split.names)
Cell.ids <- split.names[seq(1, to = length(split.names), by = 2)]
# Give each dataset a `Cell` column
seq_raw <- cbind(Cell = Cell.ids, seq_raw)
seq_target <- cbind(Cell = Cell.ids, seq_target)
# seq_cell <- cbind(Cell = Cell.ids, seq_cell)
## PCA ========================================================================
# PCA can capture most of the variance
# #because the full seq is too much to work with locally:
# seq_pca <- prcomp(seq_cell[,-1], scale = FALSE)
# #fviz_eig(seq_pca, addlabels = TRUE)
# #factoextra::get_eigenvalue(seq_pca)
#
# seq_pca <- cbind(seq_cell$Cell, as.data.frame(seq_pca$x))
# seq_pca <- rename(seq_pca, Cell = `seq_cell$Cell`)
## HVG ========================================================================
#TODO determine if HVG is useful or if we should drop it.
# temp <- seq_raw[,-1]
# temp <- t(temp)
#
# x.data <- rowMeans(temp)
# y.data <- matrixStats::rowVars(temp)
#
# ggplot()+geom_point(aes(x = log10(x.data), y = log10(y.data)), shape = 1)
#
# #https://hemberg-lab.github.io/scRNA.seq.course/biological-analysis.html#feature-selection
#
# Brennecke_HVG <- M3Drop::BrenneckeGetVariableGenes(
#   temp,
#   fdr = 0.01,
#   minBiolDisp = 0.5
# )
#
# temp <- temp[(rownames(temp) %in% Brennecke_HVG), ]
# temp <- temp %>% t()
# seq_hvg <- cbind(Cell = seq_raw[,1], as.data.frame(temp))
## Generate reduced seq sets ==================================================
seq_raw_k05 <- seq_raw[, k05$V1]
seq_target_k05 <- seq_target[, k05$V1]
# seq_cell_k05 <- seq_cell[, k05$V1]
seq_raw_k2 <- seq_raw[, k2$V1]
seq_target_k2 <- seq_target[, k2$V1]
# seq_cell_k2 <- seq_cell[, k2$V1]
# Chunk 6
# TODO determine if HVG is useful or if we should drop it.
temp <- seq_raw[,-1]
temp <- t(temp)
# x.data <- rowMeans(temp)
# y.data <- matrixStats::rowVars(temp)
#
# ggplot()+geom_point(aes(x = log10(x.data), y = log10(y.data)), shape = 1)
#https://hemberg-lab.github.io/scRNA.seq.course/biological-analysis.html#feature-selection
Brennecke_HVG <- M3Drop::BrenneckeGetVariableGenes(
temp,
fdr = 0.2, #changed to .2 to match the FDR Dr. HH provided us
minBiolDisp = 0.5
)
seq_hvg <- seq_raw[, names(seq_raw) %in% c("Cell", Brennecke_HVG)]
# temp <- temp[(rownames(temp) %in% Brennecke_HVG), ]
# temp <- temp %>% t()
# seq_hvg <- cbind(Cell = seq_raw[,1], as.data.frame(temp))
seq_hvg_target <- predict(preProcess(seq_hvg, method = c("center", "scale")), seq_hvg)
library(edgeR)
# https://combine-australia.github.io/RNAseq-R/06-rnaseq-day1.html
y <- seq_raw[,2:ncol(seq_raw)]
y <- as.matrix(y)
y <- t(y)
# Get log2 counts per million
logcounts <- cpm(y,log=TRUE)
# Check distributions of samples using boxplots
# boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# # Let's add a blue horizontal line that corresponds to the median logCPM
# abline(h=median(logcounts),col="blue")
# title("Boxplots of logCPMs (unnormalised)")
# We estimate the variance for each row in the logcounts matrix
var_genes <- apply(logcounts, 1, var)
# head(var_genes)
# Get the gene names for the top 500 most variable genes
select_var <- names(sort(var_genes, decreasing=TRUE))[1:2000]
# head(select_var)
seq_h2k <- seq_raw[, names(seq_raw) %in% c("Cell", select_var)]
seq_h2k_target <- predict(preProcess(seq_h2k, method = c("center", "scale")), seq_h2k)
# Chunk 7
mk_pca_transform <- function(d = input.df){
Cell <- d[,1]
d <- prcomp(d[,-1], scale = FALSE)
d <- cbind(Cell, d$x)
return(d)
}
pca_mrna <- mk_pca_transform(d = mrna_raw)
pca_mrna_target <- mk_pca_transform(d = mrna_target)
pca_seq <- mk_pca_transform(d = seq_raw)
pca_seq_target <- mk_pca_transform(d = seq_target)
pca_hvg <- mk_pca_transform(d = seq_hvg)
pca_hvg_target <- mk_pca_transform(d = seq_hvg_target)
pca_h2k <- mk_pca_transform(d = seq_h2k)
pca_h2K_target <- mk_pca_transform(d = seq_h2k_target)
#make sure data is in the right type
mrna_raw[, 2:ncol(mrna_raw)] <- round(mrna_raw[, 2:ncol(mrna_raw)])
seq_hvg[, 2:ncol(seq_hvg)] <- round(seq_hvg[, 2:ncol(seq_hvg)])
seq_h2k[, 2:ncol(seq_h2k)] <- round(seq_h2k[, 2:ncol(seq_h2k)])
library(optCluster)
# input.df = pca_hvg
test_clMethods <- function(input.df = mrna_raw[, 2:5],
min.k = 2,
max.k = 10,
is.count = T) {
if (is.count) {
clMethods <- c("em.nbinom", "da.nbinom", "sa.nbinom", "em.poisson", "da.poisson", "sa.poisson")
} else if (!(is.count)) {
clMethods <- c("agnes", "clara", "diana", "fanny", "hierarchical", "kmeans", "model", "pam", "som", "sota")
} else {
warning(paste0("is.count is not of type logical!"))
}
outMethods <- clMethods
for (i in clMethods) {
# print(i)
tryCatch({
optCluster(input.df,
seq(from = min.k, to = max.k, by = 1),
clMethods = i,
countData = is.count,
validation = "internal", # internal", "stability", "biological", "all"
hierMethod = "ward", # "average", "complete", "single", and "ward"
annotation = NULL, # Used in biological validation
clVerbose = FALSE, # If TRUE, the progress of cluster validation will be produced as output.
rankMethod = "CE", # cross-entropy Monte Carlo algorithm ("CE") or Genetic algorithm ("GA"). Selection of only one method is allowed
distance = "Spearman", # The two available methods are the weighted Spearman footrule distance ("Spearman") or the weighted Kendall’s tau distance ("Kendall"). Selection of only one distance is allowed.
importance = NULL,
rankVerbose = FALSE
)
}, error = function(e) {
print(paste0(
"Error for ", i
))
outMethods <<- outMethods[!(outMethods == i)]
})
}
return(outMethods)
}
data.sets <- list(
mrna_raw,
mrna_target,
pca_mrna,
pca_mrna_target,
seq_hvg,
seq_hvg_target,
seq_h2k,
seq_h2k_target,
pca_seq,
pca_seq_target,
pca_hvg,
pca_hvg_target,
pca_h2k,
pca_h2K_target
)
data.options <- data.frame(
name = c(
"mrna_raw",
"mrna_target",
"pca_mrna",
"pca_mrna_target",
"seq_hvg",
"seq_hvg_target",
"seq_h2k",
"seq_h2k_target",
"pca_seq",
"pca_seq_target",
"pca_hvg",
"pca_hvg_target",
"pca_h2k",
"pca_h2K_target"
),
min.k = rep(2, times = length(data.sets)),
max.k = c(
rep(32, times = 4),
rep(10, times = 10)
),
is.count = c(
T,F,F,F,
T,F,T,F,
F,F,F,F,F,F
)
)
clMethods.list <- list(length(data.sets))
for (i in i){
clMethods.list[[i]] <- test_clMethods(
input.df = data.sets[[i]][,-1],
min.k = data.options[i, "min.k"],
max.k = data.options[i, "max.k"],
is.count = data.options[i, "is.count"]
)
}
for (i in 1){
clMethods.list[[i]] <- test_clMethods(
input.df = data.sets[[i]][,-1],
min.k = data.options[i, "min.k"],
max.k = data.options[i, "max.k"],
is.count = data.options[i, "is.count"]
)
}
data.sets <- list(
mrna_raw[,1:10],
mrna_target,
pca_mrna,
pca_mrna_target,
seq_hvg,
seq_hvg_target,
seq_h2k,
seq_h2k_target,
pca_seq,
pca_seq_target,
pca_hvg,
pca_hvg_target,
pca_h2k,
pca_h2K_target
)
clMethods.list <- list(length(data.sets))
for (i in 1){
clMethods.list[[i]] <- test_clMethods(
input.df = data.sets[[i]][,-1],
min.k = data.options[i, "min.k"],
max.k = data.options[i, "max.k"],
is.count = data.options[i, "is.count"]
)
}
out1 <- optCluster(
obj = mrna_target[,-1],
nClust = seq(from = data.options[i, "min.k"], to = data.options[i, "max.k"], by = 1),
clMethods = c("kmeans", "model"),
countData = F,
validation = "internal", #internal", "stability", "biological", "all"
hierMethod = "ward", #"average", "complete", "single", and "ward"
annotation = NULL, #Used in biological validation
clVerbose = FALSE,
rankMethod = "CE",
distance = "Spearman",
importance = NULL,
rankVerbose = FALSE)
?optCluster
out1 <- optCluster(
obj = mrna_raw[,-1],
nClust = seq(from = data.options[i, "min.k"], to = data.options[i, "max.k"], by = 1),
clMethods = c("da.nbinom", "sa.nbinom"),
countData = F,
validation = "internal", #internal", "stability", "biological", "all"
hierMethod = "ward", #"average", "complete", "single", and "ward"
annotation = NULL, #Used in biological validation
clVerbose = FALSE,
rankMethod = "CE",
distance = "Spearman",
importance = NULL,
rankVerbose = FALSE)
i
out1 <- optCluster(
obj = mrna_raw[,-1],
nClust = seq(from = data.options[i, "min.k"], to = data.options[i, "max.k"], by = 1),
clMethods = c("da.nbinom", "sa.nbinom"),
countData = F,
validation = "internal", #internal", "stability", "biological", "all"
hierMethod = "ward", #"average", "complete", "single", and "ward"
annotation = NULL, #Used in biological validation
clVerbose = FALSE,
rankMethod = "CE",
distance = "Spearman",
importance = NULL,
rankVerbose = FALSE)
out1 <- optCluster(
obj = mrna_raw[,2:12],
nClust = seq(from = data.options[i, "min.k"], to = data.options[i, "max.k"], by = 1),
clMethods = c("da.nbinom", "sa.nbinom"),
countData = F,
validation = "internal", #internal", "stability", "biological", "all"
hierMethod = "ward", #"average", "complete", "single", and "ward"
annotation = NULL, #Used in biological validation
clVerbose = FALSE,
rankMethod = "CE",
distance = "Spearman",
importance = NULL,
rankVerbose = FALSE)
out1 <- optCluster(
obj = mrna_raw[,2:12],
nClust = seq(from = data.options[i, "min.k"], to = data.options[i, "max.k"], by = 1),
clMethods = c("da.nbinom", "sa.nbinom"),
countData = T,
validation = "internal", #internal", "stability", "biological", "all"
hierMethod = "ward", #"average", "complete", "single", and "ward"
annotation = NULL, #Used in biological validation
clVerbose = FALSE,
rankMethod = "CE",
distance = "Spearman",
importance = NULL,
rankVerbose = FALSE)
optCluster(
obj = mrna_raw[,2:6],
nClust = seq(from = data.options[i, "min.k"], to = data.options[i, "max.k"], by = 1),
clMethods = c("da.nbinom", "sa.nbinom"),
countData = T,
validation = "internal", #internal", "stability", "biological", "all"
hierMethod = "ward", #"average", "complete", "single", and "ward"
annotation = NULL, #Used in biological validation
clVerbose = FALSE,
rankMethod = "CE",
distance = "Spearman",
importance = NULL,
rankVerbose = FALSE)
optCluster(
obj = mrna_raw[,2:4],
nClust = seq(from = data.options[i, "min.k"], to = data.options[i, "max.k"], by = 1),
clMethods = c("da.nbinom", "sa.nbinom"),
countData = T,
validation = "internal", #internal", "stability", "biological", "all"
hierMethod = "ward", #"average", "complete", "single", and "ward"
annotation = NULL, #Used in biological validation
clVerbose = FALSE,
rankMethod = "CE",
distance = "Spearman",
importance = NULL,
rankVerbose = FALSE)
mrna_raw
optCluster(
obj = mrna_raw[1:20,2:4],
nClust = seq(from = data.options[i, "min.k"], to = data.options[i, "max.k"], by = 1),
clMethods = c("da.nbinom", "sa.nbinom"),
countData = T,
validation = "internal", #internal", "stability", "biological", "all"
hierMethod = "ward", #"average", "complete", "single", and "ward"
annotation = NULL, #Used in biological validation
clVerbose = FALSE,
rankMethod = "CE",
distance = "Spearman",
importance = NULL,
rankVerbose = FALSE)
optCluster(
obj = mrna_raw[1:20,2:4],
nClust = seq(from = data.options[i, "min.k"], to = 13, by = 1),
clMethods = c("da.nbinom", "sa.nbinom"),
countData = T,
validation = "internal", #internal", "stability", "biological", "all"
hierMethod = "ward", #"average", "complete", "single", and "ward"
annotation = NULL, #Used in biological validation
clVerbose = FALSE,
rankMethod = "CE",
distance = "Spearman",
importance = NULL,
rankVerbose = FALSE)
out1 <- optCluster(
obj = mrna_raw[1:20,2:4],
nClust = seq(from = data.options[i, "min.k"], to = 13, by = 1),
clMethods = c("da.nbinom", "sa.nbinom"),
countData = T,
validation = "internal", #internal", "stability", "biological", "all"
hierMethod = "ward", #"average", "complete", "single", and "ward"
annotation = NULL, #Used in biological validation
clVerbose = FALSE,
rankMethod = "CE",
distance = "Spearman",
importance = NULL,
rankVerbose = FALSE)
str(out1)
out1@rankAgg
out1@rankAgg %>% str()
out1@rankAgg$top.list %>% str()
out1.a <- out1@rankAgg$top.list
out1.a <- out1@rankAgg$top.list %>% as.data.frame()
out1.a
names(out1.a) <- "rank"
names(out1.a) <- "output"
out1.a$rank <- 1:nrow(out1.a)
out1.a
d <- separate(out1.a, output, c("Method", "k"), "-")
d
d$k <- as.numeric(d$k)
ggplot(d, aes(x = rank, y = k, color = Method))+
lemon::geom_pointline()
ggplot(d, aes(x = rank, y = k))+
lemon::geom_pointline()+
geom_point(aes(color = Method))
run.estimate <- T
save.estimate <- T
load.estimate <- T
