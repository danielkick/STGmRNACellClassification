clues::adjustedRand(
BiocGenerics::as.vector(reference.clustering),
BiocGenerics::as.vector(generated.clustering)
)
)
return(output)
}
}
# Chunk 10
generate_clusterings <- function(use.input.df = mrna_raw[, -1],
kmeans_k.param = 11,
hclust_dist.methods = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski", "correlation", "uncentered"),
hclust_clust.methods = c("ward.D", "single", "complete", "average", "mcquitty", "median", "centroid", "ward.D2"),
hclust_k.param = 11,
hclust_nboot = 10,
snnclust_verfied = FALSE,
snnclust_k.param = c(3:9),
snnclust_dist.methods = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
winnow.clusterings = FALSE) {
## K Means Clustering =========================================================
temp <- map(kmeans_k.param, function(iter.k.param) {
get_kmeans_clustering(
input.df = use.input.df,
target.nclusters = iter.k.param
)
})
param.combinations <- paste("K", as.character(
rep(kmeans_k.param, each = length(kmeans_k.param))
), sep = ".")
K.clusters <- do.call(cbind.data.frame, temp)
names(K.clusters) <- param.combinations
## Hierarchical Clustering ====================================================
# use.dist.methods <- c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski", "correlation", "uncentered") # flag thought this might cause trouble
# use.hclust.methods <- c("ward.D", "single", "complete", "average", "mcquitty", "median", "centroid", "ward.D2")
temp <- map(hclust_dist.methods, function(iter.dist) {
map(hclust_clust.methods, function(iter.hclust) {
get_hierarchical_clustering(
input.df = use.input.df,
target.nclusters = hclust_k.param,
use.method.dist = iter.dist, #
use.method.hclust = iter.hclust, #
use.nboot = hclust_nboot
)
})
})
param.combinations <- paste("H", as.character(
rep(hclust_dist.methods, each = length(hclust_clust.methods))
), as.character(
rep(hclust_clust.methods, times = length(hclust_dist.methods))
), sep = ".")
H.clusters <- do.call(cbind.data.frame, temp)
names(H.clusters) <- param.combinations
## SNN Clustering =============================================================
if (snnclust_verfied == TRUE) {
# use.k.param <- c(3:9)
# use.dist.methods <- c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski") # Note this can't use cor and uncentered like Hclust can.
temp <- map(snnclust_dist.methods, function(iter.dist) {
map(snnclust_k.param, function(iter.k.param) {
print(iter.dist)
get_SNN_clustering(
input.df = use.input.df,
use.k = iter.k.param, # number of neigbhors should go up to 9 for scPCRc
use.distance = iter.dist
) #
})
})
param.combinations <- paste("SNN", as.character(
rep(snnclust_dist.methods, each = length(snnclust_k.param))
), as.character(
rep(snnclust_k.param, times = length(snnclust_dist.methods))
), sep = ".")
SNN.clusters <- do.call(cbind.data.frame, temp)
names(SNN.clusters) <- param.combinations
}
# Merge Data Frames -----------------------------------------------------------
if (snnclust_verfied == TRUE) {
all.clusters <- cbind(K.clusters, H.clusters) %>% cbind(SNN.clusters)
} else {
all.clusters <- cbind(K.clusters, H.clusters)
}
if (winnow.clusterings == TRUE) {
# some clusterings fail and pass all values zero
# Some have a TON of clusters
num.clusters <- map(all.clusters, function(x) {
print(max(x))
}) %>% unlist() # get number of clusters in each group
real.num <- use.input.df$Cell %>% as.numeric() %>% max()
selection.vector <- (num.clusters < (2 * (real.num)) & num.clusters > (floor(real.num / 2)) & num.clusters > 1) # don't consider anything above 2X the real number.
all.clusters <- all.clusters[, selection.vector]
}
return(all.clusters)
}
score_cluster_df <- function(generated.cluster.df = out1,
true.clusters = mrna_raw[, 1]) {
# added for comparison; positive control
all.clusters <- cbind(Cell.Type = as.numeric(true.clusters), generated.cluster.df)
## Score Clusterings ==========================================================
temp <- map(all.clusters, function(iter.param) {
get_cluster_comparisons(reference.clustering = true.clusters, generated.clustering = iter.param)
})
all.clusters.scores <- do.call(cbind.data.frame, temp)
all.clusters.scores <- t(all.clusters.scores) %>% as.data.frame()
all.clusters.scores$Clustering <- row.names(all.clusters.scores)
return(all.clusters.scores)
}
#H.correlation.ward.D2 0.7566305 clustering_scores_mrna_target.csv
#H.correlation.ward.D 0.8028427 clustering_scores_seq_cell_k05.csv 5
#H.correlation.ward.D 0.8028427  clustering_scores_seq_raw_k05.csv 9
#use.index <- c("kl", "ch", "hartigan", "cindex", "db", "silhouette", "duda", "pseudot2", "ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex", "sdbw")
use.index1 <- c("kl", "ch", "hartigan", "ccc", "scott", "marriot", "trcovw", "tracew", "friedman", "rubin", "cindex", "db", "silhouette", #"duda", "pseudot2", "beale",
"ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex", "sdbw")
out1 <- map(use.index1, function(i){
print(i)
data.use <- mrna_target[, -1]
dis.matrix <- factoextra::get_dist(data.use, method = "pearson")
try(
NbClust(data = data.use,
distance = NULL,
diss = dis.matrix,
min.nc=2,
max.nc=20,
method = "ward.D2",
index = i)$Best.nc[1]
)
})
use.index2 <- c("kl", "ch", "hartigan",
#"ccc", "scott", "marriot", "trcovw", "tracew", "friedman", "rubin",
"cindex", "db", "silhouette", "duda", "pseudot2", #"beale",
"ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex", "sdbw"
)
out2 <- map(use.index2, function(i){
data.use <- seq_raw_k05[, -1]
dis.matrix <- factoextra::get_dist(data.use, method = "pearson")
print(i)
try(
NbClust(data = data.use,
distance = NULL,
diss = dis.matrix,
min.nc=2,
max.nc=20,
method = "ward.D",
index = i)$Best.nc[1]
)
})
use.index3 <- c("kl", "ch", "hartigan",
#"ccc", "scott", "marriot", "trcovw", "tracew", "friedman", "rubin",
"cindex", "db", "silhouette", "duda", "pseudot2", #"beale",
"ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex"
, "sdbw"
)
out3 <- map(use.index3, function(i){
data.use <- seq_cell_k05[, -1]
dis.matrix <- factoextra::get_dist(data.use, method = "pearson")
print(i)
try(
NbClust(data = data.use,
distance = NULL,
diss = dis.matrix,
min.nc=2,
max.nc=20,
method = "ward.D",
index = i)$Best.nc[1]
)
})
################ Test optimal
use.index4 <- c("kl", "ch", "hartigan", "ccc", "scott", "marriot", "trcovw", "tracew", "friedman", "rubin", "cindex", "db", "silhouette", "duda", "pseudot2", #"beale",
"ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex", "sdbw")
out4 <- map(use.index4, function(i){
data.use <- mrna_target_optimal[, -1]
dis.matrix <- factoextra::get_dist(data.use, method = "pearson")
print(i)
try(
NbClust(data = data.use,
distance = NULL,
diss = dis.matrix,
min.nc=2,
max.nc=20,
method = "ward.D2",
index = i)$Best.nc[1]
)
})
# DJS ask, similar to above tree
use.index5 <- c("kl", "ch", "hartigan",
#"ccc", "scott", "marriot", "trcovw", "tracew", "friedman", "rubin",
"cindex", "db", "silhouette", "duda", "pseudot2", #"beale",
"ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex"
, "sdbw"
)
out5 <- map(use.index5, function(i){
data.use <- seq_target_k05[, -1]
dis.matrix <- factoextra::get_dist(data.use, method = "pearson")
print(i)
try(
NbClust(data = data.use,
distance = NULL,
diss = dis.matrix,
min.nc=2,
max.nc=20,
method = "ward.D2",
index = i)$Best.nc[1]
)
})
convert_list2df <- function(input.list = out1){
#input.list <- out1
temp <- matrix(nrow = 1, ncol = length(use.index))
for(i in 1:length(input.list)){
if(length(as.numeric(input.list[[i]])) == 0){
temp[i] <- -1
} else {
temp[i] <- as.numeric(input.list[[i]])
}
}
temp <- as.data.frame(temp)
return(temp)
}
out1 <- convert_list2df(input.list = out1)
out2 <- convert_list2df(input.list = out2)
out3 <- convert_list2df(input.list = out3)
out4 <- convert_list2df(input.list = out4)
out5 <- convert_list2df(input.list = out5)
#some dfs didn't transpose correctly:
out1 <- as.data.frame(t(out1))
out4 <- as.data.frame(t(out4))
names(out1) <- use.index1
names(out2) <- use.index2
names(out3) <- use.index3
names(out4) <- use.index4
names(out5) <- use.index5
plt.list <- map(list(out1, out2, out3, out4, out5), function(x){
gather(x, Index, Clusters, 1:ncol(x))
})
plt.titles <- c("PCR Target", "Seq Raw 0.05", "Seq Cell 0.05", "PCR Target CellType", "Seq Target 0.05" )
for(i in 1:5){
plt <- ggplot(plt.list[[i]][plt.list[[i]]$Clusters > 0, ], aes(x = Clusters))+
geom_histogram(binwidth = 1, fill = "gray")+
geom_vline(xintercept=seq(1.5, 20.5, 1), col="white", lwd=1)+
geom_hline(yintercept=seq(1, 10, 1), col="white", lwd=1)+
xlim(0, 20)+
ylim(0, 10)+
labs(title = plt.titles[i])+
coord_capped_cart(bottom='both', left='both')
plot(plt)
}
use.index1 <- c("kl", "ch", "hartigan", "ccc", "scott", "marriot", "trcovw", "tracew", "friedman", "rubin", "cindex", "db", "silhouette", #"duda", "pseudot2", "beale",
"ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex", "sdbw")
out1 <- map(use.index1, function(i){
print(i)
data.use <- mrna_target[, -1]
dis.matrix <- factoextra::get_dist(data.use, method = "pearson")
try(
NbClust(data = data.use,
distance = NULL,
diss = dis.matrix,
min.nc=2,
max.nc=20,
method = "ward.D2",
index = i)$Best.nc[1]
)
})
use.index2 <- c("kl", "ch", "hartigan",
#"ccc", "scott", "marriot", "trcovw", "tracew", "friedman", "rubin",
"cindex", "db", "silhouette", "duda", "pseudot2", #"beale",
"ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex", "sdbw"
)
out2 <- map(use.index2, function(i){
data.use <- seq_raw_k05[, -1]
dis.matrix <- factoextra::get_dist(data.use, method = "pearson")
print(i)
try(
NbClust(data = data.use,
distance = NULL,
diss = dis.matrix,
min.nc=2,
max.nc=20,
method = "ward.D",
index = i)$Best.nc[1]
)
})
use.index3 <- c("kl", "ch", "hartigan",
#"ccc", "scott", "marriot", "trcovw", "tracew", "friedman", "rubin",
"cindex", "db", "silhouette", "duda", "pseudot2", #"beale",
"ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex"
, "sdbw"
)
out3 <- map(use.index3, function(i){
data.use <- seq_cell_k05[, -1]
dis.matrix <- factoextra::get_dist(data.use, method = "pearson")
print(i)
try(
NbClust(data = data.use,
distance = NULL,
diss = dis.matrix,
min.nc=2,
max.nc=20,
method = "ward.D",
index = i)$Best.nc[1]
)
})
################ Test optimal
use.index4 <- c("kl", "ch", "hartigan", "ccc", "scott", "marriot", "trcovw", "tracew", "friedman", "rubin", "cindex", "db", "silhouette", "duda", "pseudot2", #"beale",
"ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex", "sdbw")
out4 <- map(use.index4, function(i){
data.use <- mrna_target_optimal[, -1]
dis.matrix <- factoextra::get_dist(data.use, method = "pearson")
print(i)
try(
NbClust(data = data.use,
distance = NULL,
diss = dis.matrix,
min.nc=2,
max.nc=20,
method = "ward.D2",
index = i)$Best.nc[1]
)
})
# DJS ask, similar to above tree
use.index5 <- c("kl", "ch", "hartigan",
#"ccc", "scott", "marriot", "trcovw", "tracew", "friedman", "rubin",
"cindex", "db", "silhouette", "duda", "pseudot2", #"beale",
"ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex"
, "sdbw"
)
out5 <- map(use.index5, function(i){
data.use <- seq_target_k05[, -1]
dis.matrix <- factoextra::get_dist(data.use, method = "pearson")
print(i)
try(
NbClust(data = data.use,
distance = NULL,
diss = dis.matrix,
min.nc=2,
max.nc=20,
method = "ward.D2",
index = i)$Best.nc[1]
)
})
convert_list2df <- function(input.list = out1, index.used = use.index1){
#input.list <- out1
temp <- matrix(nrow = 1, ncol = length(index.used))
for(i in 1:length(input.list)){
if(length(as.numeric(input.list[[i]])) == 0){
temp[i] <- -1
} else {
temp[i] <- as.numeric(input.list[[i]])
}
}
temp <- as.data.frame(temp)
return(temp)
}
out1 <- convert_list2df(input.list = out1, index.used = use.index1)
out2 <- convert_list2df(input.list = out2, index.used = use.index2)
out3 <- convert_list2df(input.list = out3, index.used = use.index3)
out4 <- convert_list2df(input.list = out4, index.used = use.index4)
out5 <- convert_list2df(input.list = out5, index.used = use.index5)
out1
names(out1) <- use.index1
names(out2) <- use.index2
names(out3) <- use.index3
names(out4) <- use.index4
names(out5) <- use.index5
out1
plt.list <- map(list(out1, out2, out3, out4, out5), function(x){
gather(x, Index, Clusters, 1:ncol(x))
})
plt.titles <- c("PCR Target", "Seq Raw 0.05", "Seq Cell 0.05", "PCR Target CellType", "Seq Target 0.05" )
for(i in 1:5){
plt <- ggplot(plt.list[[i]][plt.list[[i]]$Clusters > 0, ], aes(x = Clusters))+
geom_histogram(binwidth = 1, fill = "gray")+
geom_vline(xintercept=seq(1.5, 20.5, 1), col="white", lwd=1)+
geom_hline(yintercept=seq(1, 10, 1), col="white", lwd=1)+
xlim(0, 20)+
ylim(0, 10)+
labs(title = plt.titles[i])+
coord_capped_cart(bottom='both', left='both')
plot(plt)
}
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache=TRUE)
tic <- Sys.time()
# General + Plotting ----------------------------------------------------------
library(tidyverse) #ggplot2, purrr, dplyr, tidyr mostly
library(cowplot) #clean up ggplots ands plotgrid
library(lemon) #further clean up ggplots
library(M3Drop) #for BrenneckeGetVariableGenes
# Cluster Determination -------------------------------------------------------
library(factoextra) #for fviz_nbclust
library(NbClust) #to automate cluster determination for each dataset
library(proxy) #to generate similarity/distance matrices for correlation
# Clustering ------------------------------------------------------------------
library(BiocGenerics) # This is used for clustering assessment
library(pvclust) #for pvclust
library(dendextend) #for cutree coloring dendrograms
library(NMF) #used for calculating purity metric
library(clues) #used for calculating concurrance metrics
# Classification --------------------------------------------------------------
#install.packages("caret", dependencies = c("Depends", "Suggests"))
library(caret) # for preProcess and supervised ML models
library(devtools)
source(paste0(getwd(),"/R/SNN.R"))
#devtools::load_all() #needed to have access to SNN.R
# Chunk 3: Show info to aid reproducibility
sessionInfo()
# Chunk 4: Conrol block
#What should happen to plots?
#save
#show
#What should happen to output data?
#save
#show
# SNN Cliq depend on python. This scritp is written to work on windows and hasn't been tested on Unix/Macos. Needed file is in ../Py. At the point of writing, python version 3.7 has beed tested and works
write.to.dir <- paste0(getwd(), "/inst/extdata/output_files/")
write.out.clusterings <- TRUE
write.out.classifications <- TRUE
write.out.cluster.estimates <- TRUE
use.seed <- 8743436
# Chunk 5: Pull in datasets
## Read in all data ===========================================================
k05 <- read.csv(paste0(getwd(),"/inst/extdata/kallisto0.05.csv"), header = F) %>% as.data.frame()
k2 <- read.csv(paste0(getwd(),"/inst/extdata/kallisto0.2.csv"), header = F) %>% as.data.frame()
mrna_raw <- read.csv(paste0(getwd(),"/inst/extdata/RTqPCR.csv"), row.names = "Sample", header = TRUE) %>% as.data.frame()
seq_raw <- read.csv(paste0(getwd(),"/inst/extdata/scSeq.csv"), row.names = "id", header = TRUE) %>% t() %>% as.data.frame()
## Transform RTqPCR data ======================================================
### Test optimal performance (median interpolate within transcript by cell type)
#################################### This is used for cluster estimation ####################################
#If you want to see Which values are replaced, run "nans <- is.na(M)" before this code block and "M[nans]" after. Alternatively import dplyr and use setdiff()
M <- mrna_raw
print(paste(as.character(sum(is.na(M))), " NAs to remove"))
cell_types <- unique(M$Cell)
for (i in 1:length(cell_types)){
for (ii in 2:ncol(M)){
if (sum(is.na(M[M$Cell== cell_types[i], ii])) > 0){
for (iii in 1:length(M[M$Cell== cell_types[i], ii])){
if(is.na(M[M$Cell== cell_types[i], ii][iii]) == TRUE){
M[M$Cell== cell_types[i], ii][iii] <- median(M[M$Cell== cell_types[i], ii], na.rm = TRUE)
}
}
}
}
}
if (sum(is.na(M) == 0)){
print("NAs removed")
}
mrna_raw_optimal <- M
mrna_target_optimal <- predict(preProcess(mrna_raw_optimal, method = c("center", "scale")), mrna_raw_optimal)
### Test under expected conditions
mrna_raw <- predict(preProcess(mrna_raw, method = c("medianImpute", "zv")), mrna_raw)
mrna_target <- predict(preProcess(mrna_raw, method = c("center", "scale")), mrna_raw)
mrna_cell <- mrna_raw[,-1]
mrna_cell <- as.data.frame(t(mrna_cell))
mrna_cell <- predict(preProcess(mrna_cell, method = c("center", "scale")), mrna_cell)
mrna_cell <- cbind(Cell = mrna_raw$Cell, as.data.frame(t(mrna_cell)))
## Transform Seq data =========================================================
seq_raw <- predict(preProcess(seq_raw, method = c("zv")), seq_raw)
seq_target <- predict(preProcess(seq_raw, method = c("center", "scale")), seq_raw)
# center and scale by cell
seq_cell <- seq_raw
seq_cell <- as.data.frame(t(seq_cell))
seq_cell <- predict(preProcess(seq_cell, method = c("center", "scale")), seq_cell)
seq_cell <- as.data.frame(t(seq_cell))
# Set up a cell id vector to use in each dataframe
split.names <- rownames(seq_raw) %>% strsplit("[.]")
split.names <- unlist(split.names)
Cell.ids <- split.names[seq(1, to = length(split.names), by = 2)]
# Give each dataset a `Cell` column
seq_raw <- cbind(Cell = Cell.ids, seq_raw)
seq_target <- cbind(Cell = Cell.ids, seq_target)
seq_cell <- cbind(Cell = Cell.ids, seq_cell)
## PCA ========================================================================
# PCA can capture most of the variance
#because the full seq is too much to work with locally:
seq_pca <- prcomp(seq_cell[,-1], scale = FALSE)
#fviz_eig(seq_pca, addlabels = TRUE)
#factoextra::get_eigenvalue(seq_pca)
seq_pca <- cbind(seq_cell$Cell, as.data.frame(seq_pca$x))
seq_pca <- rename(seq_pca, Cell = `seq_cell$Cell`)
## HVG ========================================================================
temp <- seq_raw[,-1]
temp <- t(temp)
# x.data <- rowMeans(temp)
# y.data <- matrixStats::rowVars(temp)
# ggplot()+geom_point(aes(x = log10(x.data), y = log10(y.data)), shape = 1)
#https://hemberg-lab.github.io/scRNA.seq.course/biological-analysis.html#feature-selection
Brennecke_HVG <- M3Drop::BrenneckeGetVariableGenes(
temp,
fdr = 0.01,
minBiolDisp = 0.5
)
temp <- temp[(rownames(temp) %in% Brennecke_HVG), ]
temp <- temp %>% t()
seq_hvg <- cbind(Cell = seq_raw[,1], as.data.frame(temp))
seq_target_hvg <- seq_target[, names(seq_target) %in% names(seq_hvg)]
seq_cell_hvg <- seq_cell[, names(seq_cell) %in% names(seq_hvg)]
## Generate reduced seq sets ==================================================
seq_raw_k05 <- seq_raw[, (names(seq_raw) %in% c("Cell", as.character(k05$V1)))]
seq_target_k05 <- seq_target[, (names(seq_target) %in% c("Cell", as.character(k05$V1)))]
seq_cell_k05 <- seq_cell[, (names(seq_cell) %in% c("Cell", as.character(k05$V1)))]
seq_raw_k2 <- seq_raw[, (names(seq_raw) %in% c("Cell", as.character(k2$V1)))]
seq_target_k2 <- seq_target[, (names(seq_target) %in% c("Cell", as.character(k2$V1)))]
seq_cell_k2 <- seq_cell[, (names(seq_cell) %in% c("Cell", as.character(k2$V1)))]
seq_pca <- prcomp(seq_cell[,-1], scale = FALSE)
fviz_eig(seq_pca, addlabels = TRUE)
96.9+1.5+0.9+0.4
dim(seq_raw)
seq_raw[1:5, 1:5]
factoextra::get_eigenvalue(seq_pca)
#fviz_eig(seq_pca, addlabels = TRUE)
#factoextra::get_eigenvalue(seq_pca)
seq_pca <- cbind(seq_cell$Cell, as.data.frame(seq_pca$x))
seq_pca <- rename(seq_pca, Cell = `seq_cell$Cell`)
dim(seq_pca)
packrat::unused_packages()
