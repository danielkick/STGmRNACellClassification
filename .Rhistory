seq_target <- predict(preProcess(seq_raw, method = c("center", "scale")), seq_raw)
# # center and scale by cell
# seq_cell <- seq_raw
# seq_cell <- as.data.frame(t(seq_cell))
# seq_cell <- predict(preProcess(seq_cell, method = c("center", "scale")), seq_cell)
# seq_cell <- as.data.frame(t(seq_cell))
# Set up a cell id vector to use in each dataframe
split.names <- rownames(seq_raw) %>% strsplit("[.]")
split.names <- unlist(split.names)
Cell.ids <- split.names[seq(1, to = length(split.names), by = 2)]
# Give each dataset a `Cell` column
seq_raw <- cbind(Cell = Cell.ids, seq_raw)
seq_target <- cbind(Cell = Cell.ids, seq_target)
seq_cell <- cbind(Cell = Cell.ids, seq_cell)
## PCA ========================================================================
# PCA can capture most of the variance
#because the full seq is too much to work with locally:
seq_pca <- prcomp(seq_cell[,-1], scale = FALSE)
#fviz_eig(seq_pca, addlabels = TRUE)
#factoextra::get_eigenvalue(seq_pca)
seq_pca <- cbind(seq_cell$Cell, as.data.frame(seq_pca$x))
seq_pca <- rename(seq_pca, Cell = `seq_cell$Cell`)
## HVG ========================================================================
#TODO determine if HVG is useful or if we should drop it.
# temp <- seq_raw[,-1]
# temp <- t(temp)
#
# x.data <- rowMeans(temp)
# y.data <- matrixStats::rowVars(temp)
#
# ggplot()+geom_point(aes(x = log10(x.data), y = log10(y.data)), shape = 1)
#
# #https://hemberg-lab.github.io/scRNA.seq.course/biological-analysis.html#feature-selection
#
# Brennecke_HVG <- M3Drop::BrenneckeGetVariableGenes(
#   temp,
#   fdr = 0.01,
#   minBiolDisp = 0.5
# )
#
# temp <- temp[(rownames(temp) %in% Brennecke_HVG), ]
# temp <- temp %>% t()
# seq_hvg <- cbind(Cell = seq_raw[,1], as.data.frame(temp))
## Generate reduced seq sets ==================================================
seq_raw_k05 <- seq_raw[, k05$V1]
seq_target_k05 <- seq_target[, k05$V1]
# seq_cell_k05 <- seq_cell[, k05$V1]
seq_raw_k2 <- seq_raw[, k2$V1]
seq_target_k2 <- seq_target[, k2$V1]
# seq_cell_k2 <- seq_cell[, k2$V1]
mrna_raw
head(seq_raw[1:10, 1:10])
gather(mrna_raw, key = "Transcript", value = "Count", 2:ncol(mrna_raw)), aes(x = Transcript, y = Cell))+
geom_tile(aes(fill = Count))+
scale_fill_gradient(low = "white", high = "steelblue")
# Heatmaps
temp <- gather(mrna_raw, key = "Transcript", value = "Count", 2:ncol(mrna_raw))
head(temp\)
head(temp)
ggplot(temp, aes(x = Transcript, y = Cell))+
geom_tile(aes(fill = Count))+
scale_fill_gradient(low = "white", high = "steelblue")
scale(d[,2])
d <- gather(d, key = "Transcript", value = "Count", 2:ncol(mrna_raw))
# Heatmaps
d <- mrna_raw
scale(d[,2])
d <- mrna_target
d <- gather(d, key = "Transcript", value = "Count", 2:ncol(mrna_raw))
ggplot(d, aes(x = Transcript, y = Cell))+
geom_tile(aes(fill = Count))+
scale_fill_gradient(low = "white", high = "steelblue")
# Heatmaps
d <- mrna_raw
d <- gather(d, key = "Transcript", value = "Count", 2:ncol(mrna_raw))
ggplot(d, aes(x = Transcript, y = Cell))+
geom_tile(aes(fill = Count))+
scale_fill_gradient(low = "white", high = "steelblue")
d <- seq_target
d <- gather(d, key = "Transcript", value = "Count", 2:ncol(mrna_raw))
ggplot(d, aes(x = Transcript, y = Cell))+
geom_tile(aes(fill = Count))+
scale_fill_gradient(low = "white", high = "steelblue")
seq_target[1:4, 1:4]
mrna_target[1:4, 1:4]
# Screeplots
seq_pca <- prcomp(mrna_raw[,-1], scale = FALSE)
# Screeplots
mrna_pca <- prcomp(mrna_raw[,-1], scale = FALSE)
fviz_eig(mrna_pca, addlabels = TRUE)
factoextra::get_eigenvalue(mrna_pca)
d <- prcomp(mrna_raw[,-1], scale = TRUE)
fviz_eig(d, addlabels = TRUE)
factoextra::get_eigenvalue(d)
fviz_eig(d, addlabels = TRUE)
factoextra::get_eigenvalue(d)
d <- prcomp(seq_raw[,-1], scale = TRUE)
fviz_eig(d, addlabels = TRUE)
factoextra::get_eigenvalue(d)
library(devtools)
install_github("vqv/ggbiplot")
library(devtools)
install_github("vqv/ggbiplot")
library(devtools)
install_github("vqv/ggbiplot")
library(devtools)
install_github("vqv/ggbiplot")
library(devtools)
install_github("vqv/ggbiplot")
library(devtools)
install_github("vqv/ggbiplot")
install.packages("rlang")
library(devtools)
install_github("vqv/ggbiplot")
library(ggbiplot)
data(wine)
wine.pca <- prcomp(wine, scale. = TRUE)
ggbiplot(wine.pca, obs.scale = 1, var.scale = 1,
groups = wine.class, ellipse = TRUE, circle = TRUE) +
scale_color_discrete(name = '') +
theme(legend.direction = 'horizontal', legend.position = 'top')
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache=F)
tic <- Sys.time()
# General + Plotting ----------------------------------------------------------
library(tidyverse) #ggplot2, purrr, dplyr, tidyr mostly
library(cowplot) #clean up ggplots ands plotgrid
library(M3Drop) #for BrenneckeGetVariableGenes
# install_github("vqv/ggbiplot")
library(ggbiplot)
# Cluster Determination -------------------------------------------------------
library(factoextra) #for fviz_nbclust
library(NbClust) #to automate cluster determination for each dataset
# Clustering ------------------------------------------------------------------
library(BiocGenerics) # This is used for clustering assessment
library(pvclust) #for pvclust
library(dendextend) #for cutree coloring dendrograms
library(NMF) #used for calculating purity metric
library(clues) #used for calculating concurrance metrics
# Classification --------------------------------------------------------------
#install.packages("caret", dependencies = c("Depends", "Suggests"))
library(caret) # for preProcess and supervised ML models
library(devtools)
devtools::load_all() #needed to have access to SNN.R
# Chunk 3: Conrol block
#What should happen to plots?
#save
#show
#What should happen to output data?
#save
#show
run.snn.cliq <- TRUE # SNN Cliq depend on python. This script is written to work on windows and hasn't been tested on Unix/Macos. Needed file is in ../Py. At the point of writing, python version 3.7 has beed tested.
write.to.dir <- paste0(getwd(), "/inst/extdata/output_files/")
use.seed <- 8743436
# Chunk 5: Pull in datasets
# Read in all data ------------------------------------------------------------
mrna_raw <- read.csv(paste0(getwd(),"/inst/extdata/RTqPCR.csv"), row.names = "Sample", header = TRUE) %>% as.data.frame()
seq_raw <- read.csv(paste0(getwd(),"/inst/extdata/scSeq.csv"), row.names = "id", header = TRUE) %>% t() %>% as.data.frame()
k2 <- read.csv(paste0(getwd(),"/inst/extdata/kallisto0.2.csv"), header = F) %>% as.data.frame()
k05 <- read.csv(paste0(getwd(),"/inst/extdata/kallisto0.05.csv"), header = F) %>% as.data.frame()
# Transform RTqPCR data -------------------------------------------------------
mrna_raw <- predict(preProcess(mrna_raw, method = c("medianImpute", "zv")), mrna_raw)
mrna_target <- predict(preProcess(mrna_raw, method = c("center", "scale")), mrna_raw)
# mrna_cell <- mrna_raw[,-1]
# mrna_cell <- as.data.frame(t(mrna_cell))
# mrna_cell <- predict(preProcess(mrna_cell, method = c("center", "scale")), mrna_cell)
# mrna_cell <- cbind(Cell = mrna_raw$Cell, as.data.frame(t(mrna_cell)))
# Transform Seq data ----------------------------------------------------------
seq_raw <- predict(preProcess(seq_raw, method = c("zv")), seq_raw)
seq_target <- predict(preProcess(seq_raw, method = c("center", "scale")), seq_raw)
# # center and scale by cell
# seq_cell <- seq_raw
# seq_cell <- as.data.frame(t(seq_cell))
# seq_cell <- predict(preProcess(seq_cell, method = c("center", "scale")), seq_cell)
# seq_cell <- as.data.frame(t(seq_cell))
# Set up a cell id vector to use in each dataframe
split.names <- rownames(seq_raw) %>% strsplit("[.]")
split.names <- unlist(split.names)
Cell.ids <- split.names[seq(1, to = length(split.names), by = 2)]
# Give each dataset a `Cell` column
seq_raw <- cbind(Cell = Cell.ids, seq_raw)
seq_target <- cbind(Cell = Cell.ids, seq_target)
seq_cell <- cbind(Cell = Cell.ids, seq_cell)
## PCA ========================================================================
# PCA can capture most of the variance
#because the full seq is too much to work with locally:
seq_pca <- prcomp(seq_cell[,-1], scale = FALSE)
#fviz_eig(seq_pca, addlabels = TRUE)
#factoextra::get_eigenvalue(seq_pca)
seq_pca <- cbind(seq_cell$Cell, as.data.frame(seq_pca$x))
seq_pca <- rename(seq_pca, Cell = `seq_cell$Cell`)
## HVG ========================================================================
#TODO determine if HVG is useful or if we should drop it.
# temp <- seq_raw[,-1]
# temp <- t(temp)
#
# x.data <- rowMeans(temp)
# y.data <- matrixStats::rowVars(temp)
#
# ggplot()+geom_point(aes(x = log10(x.data), y = log10(y.data)), shape = 1)
#
# #https://hemberg-lab.github.io/scRNA.seq.course/biological-analysis.html#feature-selection
#
# Brennecke_HVG <- M3Drop::BrenneckeGetVariableGenes(
#   temp,
#   fdr = 0.01,
#   minBiolDisp = 0.5
# )
#
# temp <- temp[(rownames(temp) %in% Brennecke_HVG), ]
# temp <- temp %>% t()
# seq_hvg <- cbind(Cell = seq_raw[,1], as.data.frame(temp))
## Generate reduced seq sets ==================================================
seq_raw_k05 <- seq_raw[, k05$V1]
seq_target_k05 <- seq_target[, k05$V1]
# seq_cell_k05 <- seq_cell[, k05$V1]
seq_raw_k2 <- seq_raw[, k2$V1]
seq_target_k2 <- seq_target[, k2$V1]
# seq_cell_k2 <- seq_cell[, k2$V1]
# Heatmaps ----
## qRT-PCR ====
d <- mrna_target
d <- gather(d, key = "Transcript", value = "Count", 2:ncol(d))
ggplot(d, aes(x = Transcript, y = Cell))+
geom_tile(aes(fill = Count))+
scale_fill_gradient(low = "white", high = "steelblue")
# Scree plots ----
## qRT-PCR ====
d <- prcomp(mrna_raw[,-1], scale = FALSE)
fviz_eig(d, addlabels = TRUE)
factoextra::get_eigenvalue(d)
ggbiplot(d, obs.scale = 1, var.scale = 1,
groups = wine.class, ellipse = TRUE, circle = TRUE) +
scale_color_discrete(name = '') +
theme(legend.direction = 'horizontal', legend.position = 'top')
ggbiplot(d, obs.scale = 1, var.scale = 1,
groups = mrna_target$Cell, ellipse = TRUE, circle = TRUE) +
scale_color_discrete(name = '') +
theme(legend.direction = 'horizontal', legend.position = 'top')
factoextra::fviz_pca_biplot(d)
factoextra::fviz_pca_biplot(d)+coord_cartesian(xlim = c(-5e06, 0))
ggbiplot(d, obs.scale = 1, var.scale = 1,
groups = mrna_target$Cell, ellipse = TRUE, circle = TRUE) +
scale_color_discrete(name = '') +
theme(legend.direction = 'horizontal', legend.position = 'top')
library(car)
# Scree plots ----
## qRT-PCR ====
d <- mrna_raw
d.id <- d[,1]
d <- prcomp(d[,-1], scale = FALSE)
fviz_eig(d, addlabels = TRUE)
factoextra::get_eigenvalue(d)
fm <- lm(d.id ~ d)
d <- cbind(d.id, d)
head(d.id)
head(d)
d <- mrna_raw
d.id <- d[,1]
d <- prcomp(d[,-1], scale = FALSE)
fviz_eig(d, addlabels = TRUE)
factoextra::get_eigenvalue(d)
str(d)
factoextra::get_eigenvalue(d)
d$x
cbind(d.id, d$x)
d <- cbind(d.id, d$x)
head(d)
fm <- lm(d.id ~ .)
fm <- lm(d.id ~ ., data = d)
fm <- lm(d.id ~ ., data = as.data.frame(d))
Anova(fm)
d.anova <- Anova(fm)
d.anova$`Pr(>F)`
library(dunn.test)
install.packages("dunn.test")
library(dunn.test)
dunn.test::dunn.test(d.anova$`Pr(>F)`, method = sidak)
?dunn.test
dunn.test::dunn.test(d.anova$`Pr(>F)`, method = "sidak")
d.anova$`Pr(>F)` %>% str()
d.anova$Df
str(d.anova)
dunn.test::dunn.test(d.anova$`Pr(>F)`, g = 1:66, method = "sidak")
dunn.test::dunn.test(d.anova$`Pr(>F)`, g=NA, adjustment.method = "sidak")
dunn.test::dunn.test(d.anova$`Pr(>F)`, g=NA, method = "sidak", label = T, wrap = F, alpha = 0.05)
install.packages("mutoss")
s
library(mutoss)
install.packages("multtest")
# TODO determine if HVG is useful or if we should drop it.
temp <- seq_raw[,-1]
temp <- t(temp)
x.data <- rowMeans(temp)
y.data <- matrixStats::rowVars(temp)
ggplot()+geom_point(aes(x = log10(x.data), y = log10(y.data)), shape = 1)
Brennecke_HVG <- M3Drop::BrenneckeGetVariableGenes(
temp,
fdr = 0.01,
minBiolDisp = 0.5
)
Brennecke_HVG
temp <- temp[(rownames(temp) %in% Brennecke_HVG), ]
head(temp)
temp <- temp %>% t()
head(temp)
temp(1:10, 1:10)
temp <- seq_raw[,-1]
temp <- t(temp)
x.data <- rowMeans(temp)
y.data <- matrixStats::rowVars(temp)
ggplot()+geom_point(aes(x = log10(x.data), y = log10(y.data)), shape = 1)
#https://hemberg-lab.github.io/scRNA.seq.course/biological-analysis.html#feature-selection
Brennecke_HVG <- M3Drop::BrenneckeGetVariableGenes(
temp,
fdr = 0.01,
minBiolDisp = 0.5
)
temp <- temp[(rownames(temp) %in% Brennecke_HVG), ]
temp <- temp %>% t()
temp[1:10, 1:10]
seq_raw[1:10, 1:10]
dim(seq_raw)
dim(seq_raw[, names(seq_raw) %in% c("Cell", Brennecke_HVG)])
dim(seq_target_k05)
d <- seq_hvg
# TODO determine if HVG is useful or if we should drop it.
temp <- seq_raw[,-1]
temp <- t(temp)
# x.data <- rowMeans(temp)
# y.data <- matrixStats::rowVars(temp)
#
# ggplot()+geom_point(aes(x = log10(x.data), y = log10(y.data)), shape = 1)
#https://hemberg-lab.github.io/scRNA.seq.course/biological-analysis.html#feature-selection
Brennecke_HVG <- M3Drop::BrenneckeGetVariableGenes(
temp,
fdr = 0.01,
minBiolDisp = 0.5
)
seq_hvg <- seq_raw[, names(seq_raw) %in% c("Cell", Brennecke_HVG)]
# temp <- temp[(rownames(temp) %in% Brennecke_HVG), ]
# temp <- temp %>% t()
# seq_hvg <- cbind(Cell = seq_raw[,1], as.data.frame(temp))
d <- seq_hvg
d <- gather(d, key = "Transcript", value = "Count", 2:ncol(d))
ggplot(d, aes(x = Transcript, y = Cell))+
geom_tile(aes(fill = Count))+
scale_fill_gradient(low = "white", high = "steelblue")
seq_hvg_target <- predict(preProcess(seq_hvg, method = c("center", "scale")), seq_hvg)
d <- seq_hvg_target
d <- gather(d, key = "Transcript", value = "Count", 2:ncol(d))
ggplot(d, aes(x = Transcript, y = Cell))+
geom_tile(aes(fill = Count))+
scale_fill_gradient(low = "white", high = "steelblue")
#Note: Must contain a column called "Cell"
run_supervised_models <- function(use.seed = 8743436,
input.df = use.input.df){
#use.seed = 8743436
#input.df = mrna_target
set.seed(use.seed)
glmnetm <- train(
Cell ~ ., input.df,
metric = "Accuracy",
method = "glmnet",
tuneGrid = expand.grid(
alpha = seq(0, 1, length = 5),
lambda = seq(0.0001, 1, length = 100)
),
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
# Plot the results
#plot(glmnetm)
#kNN
set.seed(use.seed)
knnm <- train(
Cell ~ . ,
tuneGrid = expand.grid(k = seq(from =1, to =20, by = 1)),
#tuneLength = 20,
data = input.df,
method = "knn",
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
#plot(knnm)
#print(max(knnm$results$Accuracy, na.rm = T))
#LDA
set.seed(use.seed)
ldam <- train(
Cell ~ . ,
data = input.df,
method = "lda",
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
#print(ldam)
#neural networks
set.seed(use.seed)
nnmm <- train(
Cell ~ . ,
data = input.df,
tuneGrid = expand.grid(decay = seq(from = 0.1, to = 1, by = 0.05)),
method = "multinom",
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
#plot(nnmm)
#print(max(nnmm$results$Accuracy, na.rm = T)) #81% accuracy
set.seed(use.seed)
nnm <- train(
Cell ~ . ,
data = input.df,
tuneGrid = expand.grid(size = seq(from = 1, to = 12, by = 1),
decay = seq(from = 0.1, to = 1.0, by = 0.2)),
method = "nnet",
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
#plot(nnm)
#print(max(nnm$results$Accuracy, na.rm = T))
#random forest
max.mtry = 30
set.seed(use.seed)
rfm <- train(
Cell ~ . ,
#tuneLength = 3,
tuneGrid = data.frame(mtry = rep(seq(1, max.mtry, by = 1), times = 2), #mtry can be any number from 2 to the number of columns
splitrule = rep(c("extratrees", "gini"), each = max.mtry), #the docs make it look like these are the two to use for classification
min.node.size = rep(2, each = (max.mtry*2))),
data = input.df,
method = "ranger",
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
#print(rfm)
#plot(rfm)
#print(max(rfm$results$Accuracy, na.rm = T))
#svm
set.seed(use.seed)
svm.rad <- train(
Cell ~ .,
tuneGrid = expand.grid(sigma = seq(from = 0.001, to = 0.5, by = 0.01),
C = seq(from = 0.5, to = 5.5, by = 1)),
data = input.df,
method = "svmRadial",
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
#svm.rad
#plot(svm.rad)
#print(max(svm.rad$results$Accuracy, na.rm = T))
set.seed(use.seed)
svm.lin <- train(
Cell ~ .,
tuneGrid = expand.grid(cost = seq(from = 0.001, to = 0.5, by = 0.01)),
data = input.df,
method = "svmLinear2",
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
#return(list(knnm,ldam,nnmm,nnm,rfm,svm.rad,svm.lin))
return(list(GLMNet=glmnetm,
kNN=knnm,
LDA=ldam,
NNet=nnm,
NNet.Multinom=nnmm,
Rand.Forest=rfm,
SVM.Radial=svm.rad,
SVM.Linear=svm.lin))
}
input.df = seq_hvg_target
use.seed = 8743436
set.seed(use.seed)
glmnetm <- train(
Cell ~ ., input.df,
metric = "Accuracy",
method = "glmnet",
tuneGrid = expand.grid(
alpha = seq(0, 1, length = 5),
lambda = seq(0.0001, 1, length = 100)
),
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
warnings()
plot(glmnetm)
#kNN
set.seed(use.seed)
knnm <- train(
Cell ~ . ,
tuneGrid = expand.grid(k = seq(from =1, to =20, by = 1)),
#tuneLength = 20,
data = input.df,
method = "knn",
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
#LDA
set.seed(use.seed)
plot(knnm)
#LDA
set.seed(use.seed)
ldam <- train(
Cell ~ . ,
data = input.df,
method = "lda",
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
print(ldam)
#neural networks
set.seed(use.seed)
nnmm <- train(
Cell ~ . ,
data = input.df,
tuneGrid = expand.grid(decay = seq(from = 0.1, to = 1, by = 0.05)),
method = "multinom",
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE)
)
plot(nnmm)
warnings()
?trainControl
